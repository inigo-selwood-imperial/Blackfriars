/*
Components of the application:
    (1) Parse buffer (class)
        - allows easy iteration of a block of text, accessing characters or
            strings at a given index within it

    (2) Matrix (class)
        - represents 2D matrices of given sizes
        - functions for multiplication, inversion, etc.

    (3) CSV (namespace)
        - functions for reading and writing data in CSV format

    (4) NewtonRaphson (namespace)
        - functions for calculating numerical solutions for non-linear circuits

    (5) Schematic (class)
        - contains all the information necessary to represent a circuit or node
            (passives, nodes, etc.)
        - function for finding the voltage value at each node in the circuit at
            a given point in time, obtained by solving a conductance matrix
*/

class ParseBuffer {

    // constructor which accepts a string of text to be iterated through
    ParseBuffer(const std::string &text);

    // returns the character at the current index, or 0 if the end of the text has
    // been reached
    char get_current() const;

    // returns the next character, or 0 if the end of the text has been reached
    char get_next() const;

    // true if the end of the text has been reached
    bool end_reached() const;

    // increment the position within the text, returning the character which has
    // been skipped past
    char skip_current();

    // increment the position within the text, only if the character at the current
    // position matches the character specified. Otherwise, return 0
    char skip_character(const char &character);

    // skips whitespace characters, where the bit 0b001 represents spaces, 0b010
    // represents tabs, and 0b100 represents newline characters
    std::string skip_whitespace(const int &flags);

    // gets the position within the text (the position struct contains data like
    // the indentation, line and column number, etc.)
    Position get_position() const;

    // sets the position of the buffer within the text
    void set_position(const Position &position);

};

class Matrix {

    // finds the dot product of two matrices
    static double dot_product(const Matrix &one, const Matrix &two);

    // finds the cross product of two matrices
    static Matrix cross_product(const Matrix &one, const Matrix &two);

    // returns the identity matrix of a given size
    static Matrix identity(const unsigned int &size);

    // returns the value of the matrix at a given column and row
    double &operator[](const unsigned int &column, const unsigned int &row);

    // constructs a matrix from given values
    Matrix(const std::vector<std::vector<double>> &values);

    // constructs an empty matrix of a given size
    Matrix(const unsigned int &width, const unsigned int &height);

    // returns the inverse of the matrix
    Matrix inverse() const;

    // returns the determinant of the matrix
    double determinant() const;

};

namespace CSV {

    // Returns a string containing the text of a line in CSV format
    static std::string print_line(const std::vector<std::string> &line);

    // Returns a string containing the text of a vector of lines in CSV format
    // (space delimiters and newlines)
    std::string print(const std::vector<std::vector<std::string>> &data);

};

namespace NewtonRaphson {

    // NOTE: Don't actually know what's gonna go here, gonna have to work that
    // out later.
    double newton_raphson(const std::function<double(double)> &function) {}

};

class Component {

    // TODO: Add more components
    enum Type {
        CAPACITOR,
        INDUCTOR,
        RESISTOR,

        CURRENT_SOURCE,
        SIGNAL_SOURCE,
        VOLTAGE_SOURCE,

        DIODE,
        NPN_TRANSISTOR,
        PNP_TRANSISTOR
    };

    typedef std::shared_ptr<Component> Pointer;

    const Type type;

    // Cast a Component::Pointer to a templated type
    template <typename DerivedComponent>
    static std::shared_ptr<DerivedComponent> cast(const Pointer &pointer);

    Component(const Type &type) : type(type) {}

};

template <typename DerivedType, Component::Type type>
class ProxyCompomponent : public Component {

    typedef std::shared_ptr<DerivedType> Pointer;

    ProxyComponent() : Component(type) {}

};

class Schematic {

    std::vector<Component::Pointer> components;

    // Create a schematic from a netlist
    Schematic(const std::string &netlist);

    // Find the voltage value at a given node
    double voltage(const std::string &node);

};

namespace SPICEFormat {

    // Create a schematic from a SPICE netlist
    Schematic parse(const std::string &text);

};
