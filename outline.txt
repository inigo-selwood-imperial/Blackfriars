Looking at the brief, there's a clear problem to solve, and several compromises to make. The tasks are as follows:
    (1) Parse a SPICE netlist
    (2) Create an equation of matrices to solve for the matrices which find the node voltages, and the currents through each voltage source
    (3) Serialise the results in .csv format

Parsing the SPICE netlist seems simple, but it depends on how strictly you adhere to the SPICE specification. In the brief, each component and node is designated with a character, and a zero-prefixed integer (eg: N001 for a node, Q003 for a transistor, etc.). Furthermore, the specification states that the application need only ever deal with a DC transient simulation.

At first, the application treated each component definition as a component symbol, and a unique designator number (for example, D021 would be a composite of the symbol 'D' and the designator '21'). Once we'd realized that SPICE schematics could save string values for names however, we moved to a system that supported strings rather than symbols and delimiters.

This alteration took a toll on simulation times -- specifically, when it came to nodes. If each component saved its nodes as strings, the simulation step would take ages, because each node name would have to be looked up in a map of strings, and string comparisons take ages. It would've been possible to place a function in the 'schematic' class which assigned each component a unique designator, and each of it's nodes their own index -- but this detracted from the spirit of having each component as a self-contained data structure. Namely, it wouldn't be possible for each component to derive this information without knowledge of all the other components in the circuit.

So, to combat the problem, each component stores a hash of the string representing its name and its nodes. A hash (an unsigned integer) is far quicker to look up in a map, and can also be traced back to its original string form. This backwards operation is more computationally expensive, but it's only performed once when the simulation's output is serialized, rather than once every simulation step.

This process was further sped-up by storing the component's hashes in an unordered map. This is a little more memory-intensive, but saves on runtime cycles. From what information is available on 'cppreference.com', unordered maps use the values' keys as the memory indices (which likely involves some sort of intermediate index hash table, but who can tell). This effectively offset the runtime cost of string comparisons for each component.

This means that a balance had to be struck between fulfilling the needs of the task, and handling the outputs of SPICE simulations which we might use for testing. There were several discrepancies between how the specification told us the application would be tested, and how SPICE GUI wrappers (such as LTSpice) actually output data. For instance:

    - The micro prefix isn't a 'u' character, but rather a UTF-8 encoded greek 'mu' symbol
    - Transient operations are treated differently based on how many arguments are provided. If there's only one argument, it's treated as the stop-time, whereas the specification cited them as taking up to three arguments, in a totally different order
    - LTSpice and similar programs output a range of different commands, in addition to the '.tran' DC simulation command. For example: '.backannotate' and '.end'. The program doesn't technically need to deal with these commands, but it needs to be able to parse the netlist without crashing.
    - Versatility of the simulation application requires that the program handle unexpected inputs in a graceful manner (ie: not throwing an error when unexpected inputs are encountered)

These considerations mean that the application needs to handle a variety of inputs if it's to meet the examination criteria, and also cope with a range of text inputs, if it's to be easily tested using outputs from programs like LTSpice.

So, the approach taken was to create a clear hierarchy of functions which would return clear error states, and provide error messages through the standard error stream (std::cerr).

Initially, we created an logging class, which would provide functions for logging errors and debugging information, but this was later removed. We decided to remove it because: it relied on a global namespace of class instances, which isn't sustainable in a multi-threaded application (which might have been necessary if the scope of the application was increased), and because it further complicated the error reporting procedure.

Breaking down the task, we decided to create the following classes:
    (1) Simulation class
        Holds the operation and the schematic
    (2) Operation class
        This polymorphic class holds the operation to be performed (DC analysis etc). The reason it was made polymorphic was to allow for future expansion, and to better follow the example set by SPICE (allowing for other operations such as AC analysis)
    (3) Schematic class
        This class holds all the information about the physical circuit, such as the components and nodes which comprise it.
    (4) Component class
        This base class is what all the simulate-able components in the class are derived from, and allows them to be held in a single polymorphic container by the simulation class.

        Each of the derived component classes must provide a parse function (which creates a component from the LTSpice component format), and a templated simulate function, which, depending on the type of operation, delegates the task of implementing component-specific logic to the components themselves.

        The components were broken down into three categories, and a number of subcategories:
            a) Passive components
                - Capacitors
                - Inductors
                - Resistors
            b) Source components
                - Voltage sources
                - Current sources
            c) Semiconductors (un-implemented)
                - Diodes
                - Transistors

        This structure defined an inheritance tree, which reduced the quantity of repeated code (for instance, all source components shared the same time-based value function, and all semiconductors need access to the Boltzmann constant, etc.)

    (5) Matrix class
        From the beginning, it was an option to use an off-the-shelf matrix library (such as that provided in the GNU scientific library), but the overhead in such libraries seemed to great to use in this application. Instead, we opted for writing out own matrix library. This had the following advantages:

            - Clearer syntax, in line with the code already in our source file
            - No dependencies, which would have further increased compile time
            - Intellectual challenge, providing us with a deeper understanding of the operations involved in matrix manipulation
            - Versatility, allowing us to add and remove functions as necessary to suit the needs of the application

    (6) Parse class
        The parse buffer was adapted from an earlier project of Inigo's, where he used the same structure as part of a JSON parsing library. It allows the various component classes to move through a body of text, parsing the syntax as necessary, and also made error reporting much simpler.

The next task, having outlined the classes used in the program, was to define how the simulation was run. For this, we referenced several online sources for the details of MNA (modified nodal analysis)
    - The QUCS (an open-source analogue program) technical docs.
    - 'How LTSpice works', a paper written by the electronics engineering department of the university of Pugate Sound

These sources outlined a multi-step process for creating a solvable matrix equation. The components are as follows:

    (1) A conductance matrix containing information about each resistive element in the schematic (in the case of this application, only resistors)
    (2) A voltage source signed boolean matrix, which dictated which nodes the circuit's voltage sources applied
    (3) A constants matrix containing the predefined currents and voltages in the circuit

One of the problems we repeatedly encountered was that of equality testing between floating point numbers (actually, 'double' values in the case of this application). To combat the inherent inaccuracies, we used the value defined in 'std::numeric_limits<double>::epsilon'. This meant that for each calculation, we could account for the discrepancy inherent in these calculations -- at least for small values.

Initially, the program was written to iterate through each component in the schematic, and apply different logic based on a 'Component::Type' enumereated field. This was rejected in favour of delegating the task to the components themselves. We made this decision for two reasons

    - It was cluttered to deal with each component in a single function
    - This structure would make it difficult to add new components in the future
    - It made it harder to support a variety of different operations
    - This approach involved using the 'std::dynamic_cast' function, which is costly at run-time, since it involves RTTI (run-time type information)

Rather, it was decided to give each component a templated 'simulate' function, which would vary depending on the type of simulation provided. This meant that the amount of code in the operation source files was reduced, and that it was easier to implement new types of component (specifically, we were concerned about the complexity of adding diodes and transistors to the simulation)

Simulating capacitors and inductors proved to be a large problem. Having read the QUCS technical documentation, we tried to implement these components as varying resistances in the circuit -- until it became clear that this made simulation very difficult. Specifically, the QUCS docs. used the typical impedance formulae for these reactive components, and it became clear that calculating an omega value for the potential across them was close to impossible.

Referencing a question on Piazza, we opted to model capacitors and inductors as voltage sources and current sources respectively. This meant overhauling our operation class significantly, since it now needed to hold historical data about the currents and voltages in the circuit. We did this because we wanted the component classes to remain data-only, and to be versatile for different operations. If we included information like current or voltage integrals, this would become redundant with, for instance, noise operations. Given that these classes were "data only", it might seem surprising that they were made classes at all -- but it must be remembered that they still contain some application-specific logic.

Before this realisation was reached, we'd written an entire complex number class, which the matrix class supported. This had to be removed once we switched to a current/voltage integral method.

The next problem we encountered was that of parallel voltage sources, and series current sources. This wouldn't have seemed like so large of a problem, but it must be remembered that capacitors and inductors were treated as such, and so it became almost impossible not to encounter this situation during simulations.

When we simulated this particular scenario, the program failed on account of the conductance matrix having a 'zero determinant'. Initially, we thought that this was a problem with the matrix class, and we set about overhauling the matrix's determinant function. In the end, this proved useful, but didn't solve the problem.

Beforehand, we'd been using a method called L-U (lower-upper) decomposition to find the determinants of our matrices. This is less computationally expensive than the Gauss-Jordan method, but is unstable given some conditions. This zero-determinant issue was fixed by adding partial pivoting (selecting the row with the greatest diagonal value during decomposition, as opposed to iterating through each row in order of which one was encountered first). It may be the case that partial decomposition fails to find the determinants of certain matrices, but since the conductance matrix is diagonally symmetric, this won't be the case in this application.

Having fixed the determinant problem, some circuits became solve-able, but not others. The problem with charge sources remained. We came up with two solutions to solve this problem:

    - Combine parallel voltage sources and serial current sources into a single compound component, eliminating the need for two conflicting entries in the conductance and constant matrices
    - Add series and parallel resistances to voltage and current resistances respectively

There were disadvantages to both approaches. Specifically, combining voltage and current sources would require either altering the schematic itself, or extending the amount of time required for each simulation by taking time to perform a combination stage. Similarly, adding series/parallel resistors takes the simulation away from the realm of ideality, and also involves altering the schematic itself.

In the end, we opted for adding series/parallel resistors of very small values. Ultimately, these values are only necessary for the matrix maths to work properly, and they can be made small enough to have no significant impact on the simulation. Furthermore, since an emphasis was placed on the application's power consumption, it seemed wise to sacrifice memory for computational speed, in this case.

In the future, there are a number of steps we would take to improve the perfomance of the program:

    - Use a library like 'thrust' or the underling NVidida 'CUDA' library to harness GPU optimization, and speed up the matrix calculations. This would result in a lower power consumption, and reduce the time taken for any given simulation
    - Create a 'print' function for each of the components, which would greatly simplify debugging the schematic's parse stage
    - Distinguish between the time-variant and constant-value components, to reduce the time taken for each simulation step. In our current implementation, components like resistors need to copy themselves to the simulation's conductance matrix once per simulation step, which wastes clock cycles. Ideally, they'd be stored seperately, and their values set just once at the start of the simulation
    - Add non-ideal models for each of the components. Currently, none of the components factor in properties like ESR (equivalent series resistance), leakage currents, or inductive coupling. Granted, the last of those factors would involve spacial data which is beyond the scope of this program -- but it's implemented in some applications wrapping SPICE
    - Dependent current and voltage sources. Provision has been made for these sorts of components in the transient simulation class -- but they haven't been implemented, since they weren't included in the application specification -- not to mention, they'd be difficult to handle.
